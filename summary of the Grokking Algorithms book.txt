Конспект по книге Грогаем алгоритмы.
Chapter 1
Один из самых быстрых алгоритмов поиска в сортированном списке, в целом выглядит так:
1. Определяем функцию которая принимает два аргумента - массив и искомое число.
2. Определяем две переменные, первая ссылается на индекс первого элемента массива, вторая индекс последнего элемента массива.
3. Запускаем цикл который работает пока индекс последнего элемента цикла больше либо равен индексу первого элемента.
4. Определяем переменную middle которая хранит ссылку на вычисляемый средний индекс массива (low + high) // 2
5. Определяем переменную middle_value принимающую значение элемента массива с индексом middle.
6. Ветвление: 	если middle_value == desired_number, т е среднее значение равно искомому значению, возвращаем middle
				если middle_value > desired_number, то верхнее значение индекса массива принимает значение middle - 1
				иначе нижнее значение индекса списка принимает middle + 1
Функция возвращает None если ничего не найдено.

def binary_search(list, desired_number):  # определяем функцию, которая принимает на вход массив и искомое число
    low = 0  # первый индекс массива
    high = len(list) - 1  # последний индекс массива

    while low <= high:
        middle = (low + high) // 2  # делить обязательно // чтобы не получить float
        middle_value = list[middle]  # переменная принимает значение текущей середины массива
        if middle_value == desired_number:  # если число найдено, возвращаем индекс
            return middle
        elif middle_value > desired_number: # если искомое число меньше значения середины массива, верхний край 
            # массива переносим в середину 
            high = middle - 1
        else:   # если искомое число больше значения середины массива, нижний край массива переносим в середину
            low = middle + 1
    return None


my_list = [1, 2, 3, 5, 6, 7, 9, 10]
print(binary_search(my_list, 7))
print(binary_search(my_list, 15))

Chapter 2
Sort of choise

Для начала разберем функцию поиска наименьшего элемента массива. Алгоритм:
1. Определим функцию которая принимает в качестве аргумента массив.
2. Определим две переменные, одна будет принимать наименьшее значение массива( например smallest), другая индекс этого значения(smallest_index).
3. В цикле for с помощью range() итерируем массив начиная со второго элемента(первый элемент уже лежит в smallest). Если текущий элемент массива arr[i] < smallest, то это значение передаем в smallest, a его индекс в smallest_index.
4. Цикл for возвращает индекс наименьшего числа.

def find_smallest(arr):
    smallest = arr[0]  # первое значение массива
    smallest_index = 0  # инициируем переменную для индекса
    for i in range(1, len(arr)):  # итерация массива
        if arr[i] < smallest:  # ищем наименьшее текущее значение
            smallest = arr[i]  # если находим, записываем в переменную
            smallest_index = i  # записываем индекс наименьшего значения
    return smallest_index  # в результате функция вернет индекс наименьшего значения

Теперь напишем алгоритм для функции сортировки:
1. Определим функцию.
2. Создадим пустой массив sort_arr, куда будем принимать сортировку.
3. В цикле for итерируем массив len(arr) раз.
	Каждую итерацию вызываем фукцию find_smallest() и присваиваем возвращаемое значение smallest.
	Также каждую итерацию для массива sort_arr применяем метод append, который добавит текущее значение в конец массива. append 		принимает аргументом сортируемый массив arr c примененным к нему методом pop, который вырежет из массива текущее значение 		smallest, и вернет его для append.
4. Цикл for возвращает отсортированный массив sort_arr

На основе двух функций производим сортировку массива по возрастанию:

def find_smallest(arr):
    smallest = arr[0]  # первое значение массива
    smallest_index = 0  # инициируем переменную для индекса
    for i in range(1, len(arr)):  # итерация массива
        if arr[i] < smallest:  # ищем наименьшее текущее значение
            smallest = arr[i]  # если находим, записываем в переменную
            smallest_index = i  # записываем индекс наименьшего значения
    return smallest_index  # в результате функция вернет индекс наименьшего значения


def sort_by_choise(arr):
    sort_arr = []  # массив который будет принимать сортированные значения
    for i in range(len(arr)):
        smallest = find_smallest(arr)  # при каждой итерации возвращается наименьшее значение массива arr
        sort_arr.append(arr.pop(smallest))  # при каждой итерации в конец нового массива добавляется  
        # вырезанное из сортируемого массива значение 
    return sort_arr  # возвращаем новый сортированный массив


my_arr = [2, 1, 9, 7, 14, 3, 18, 11]
print(sort_by_choise(my_arr))

Chapter 3

Рекурсия. При использовании рекурсии необходимо установить базовый случай. Базовый случай должен быть простейшим. Это условие при достижении которого вызов рекурсии прекращается. Алгоритм использования рекурсии при вычислении факториала:
1. Определить функцию.
2. Используя ветвление определить базовый случай и вызвать рекурсию:
	если достигнуто условие базового случая, выходим из функции
	в противном случае вызываем рекурсию.
3. Возвращаем вычисленное значение.

def calculation_of_factorial_by_recursion(num):
	if num == 0:	# базовый случай
		return 1
	return num * calculation_of_factorial_by_recursion(num - 1)	# рекурсивный вызов продолжится до тех пор пока num не достигнет базового 		#случая

def calculation_of_factorial_by_cycle(num):	# вспомним как расчитать факториал в цикле
	factorial = 1
	for i in range(2, num + 1):
		factorial *= i 
	return factorial

Chapter 4
Quick sort.

Необходимо написать рекурсивную функцию для суммирования чисел в массиве. Составим алгоритм:
1. Определим функцию.
2. Определим базовый случай для принимаемого массива и используем его для условия ветвления. Для рекурсивной функции с использованием массива базовым случаем чаще всего будет пустой массив или массив из одного элемента. Если массив пустой возвращаем ноль.
3. В противном случае возвращаем первый элемент массива + рекурсия принимающая срез массива от второго элемента.

def calculation_of_sum_arr_by_recursion(arr):
	if arr == []:	#  определяем базовый случай. Также эта запись может выглядеть так: if not arr
		return 0
	return arr[0] + calculation_of_sum_arr_by_recursion(arr[1:])	#  функция будет вызывать себя пока элементов в массиве не останется,	
	 # отбрасывая каждый вызов первый элемент массива. При этом вызванные функции в стэке встанут на паузу пока не будет достигнут 
	 # базовый случай. После этого каждая функция завершится, вернув свое значение. По сути каждая функция будет возващать по одному 		 # элементу массива.

print(calculation_of_sum_arr_by_recursion([1, 2, 3, 4]))

Подсчитаем колличество элементов в массиве:
def calculation_of_item_in_arr_by_recursion(arr):
	if not arr:
		return 0
	return 1 + calculation_of_item_in_arr_by_recursion(arr[1:])

Найдем наибольшее число в списке. Создадим алгоритм:
1. Определим функцию.
2. Определим базовый случай в первой части ветвления if.
3. Else: Определим переменную которая будет принимать значение рекурсивной функции.
4. Используем ветвление: если значение вышеуказанной переменной больше первого элемента массива, возвращаем значение переменной, 	в противном случае возвращаем первый элемент массива.

def search_max_value_arr_by_recursion(arr):
    if not arr:  # если массив пуст
        return 0
    else:
        max_value = search_max_value_arr_by_recursion(arr[1:])  # в каждом экземпляре получаем очердное значение массива
        if max_value > arr[0]:  # сравниваем его с первым элементом массива, его передаст отработавшая функция.
            return max_value
        return arr[0]  # значение из предыдущей функции

data = [8, 2, -690, 4, 12, -320, 0, 98]
print(search_max_value_arr_by_recursion(data))

Базовым случаем для бинарного поиска в сортрированном списке будет один элемент массива.

Быстрая сортировка. В массиве выделяется любой элемент, который используется для как опорное число. С помощью рекурсии массив разбивается до базового случая. Содержимое массива сравнивается с опорным числом. Если меньше сортируется в левый массив, по отношению к опорному, если больше - в правый массив. В конце левая часть, опорное число, правая часть - собираются в один массив.

def quick_sort(array):
    if len(array) < 2:
        return array
    else:
        pivot = array[0]
        less = [i for i in array[1:] if i <= pivot]
        greater = [i for i in array[1:] if i > pivot]

    return quick_sort(less) + [pivot] + quick_sort(greater)


print(quick_sort([3, 1, 12, 52, 10, 4, 9, -10]))


Chapter 6
Breadth-first search.

Графы реализованы в Python в качестве словарей. Графы имеют узлы и ребра и призваны найти кратчайшее и самое дешевое расстояние от узла A до узла B. Задача: найти среди друзей в телефонной книге продавца манго.
Алгоритм поиска состоит из 6 пунктов:
1. Create a new dictionary where a key equal name of human, value equal friends of human.
2. Extract a next person.
3. Check an unverified person.
4. There is a branch here: if human is a mango's seller - ends a cycle, else adds all friends of human.
5. Cycle works.
6. If the queue is empty the end.

from collections import deque  # функция  deque() создает очередь из итерируемого объекта

graph = {}
graph["you"] = ["alice", "bob", "claire"]
graph["bob"] = ["anuj", "peggy"]
graph["alice"] = ["peggy"]
graph["claire"] = ["thom", 'jonny']
graph["anuj"] = ["mango"]
graph["peggy"] = []
graph["thom"] = []
graph["jonny"] = []


def search(name):
    search_queue = deque()  # создает новую очередь
    search_queue += graph[name]  # alice, bob, claire добавляются в очередь поиска
    searched = []  # массив для отслеживания проверенных людей
    while search_queue:  # so search_queue == True
        person = search_queue.popleft()  # popleft() - удаляет и возвращает первый элемент очереди
        if person not in searched:  # проверка продолжится при условии что человек ранее не проверялся
            if person_is_seller(person):  # функция проверяет евляется ли человек продавцом манго
                print(person + " is a mango seller!")
                return True
            else:
                search_queue += graph[person]  # если не является, все его друзья добавляются в очередь поиска
                searched.append(person) # проверенных людей добавляем в массив
    return False  # выходим из цикла если перебрали всех друзей и продавец не найден

def person_is_seller(name):
    return name[:] == 'mango'  # если есть имя  'mango' , то он продавец манго

search("you")
	
