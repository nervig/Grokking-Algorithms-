Конспект по книге Грогаем алгоритмы.
Chapter 1
Один из самых быстрых алгоритмов поиска в сортированном списке, в целом выглядит так:
1. Определяем функцию которая принимает два аргумента - массив и искомое число.
2. Определяем две переменные, первая ссылается на индекс первого элемента массива, вторая индекс последнего элемента массива.
3. Запускаем цикл который работает пока индекс последнего элемента цикла больше либо равен индексу первого элемента.
4. Определяем переменную middle которая хранит ссылку на вычисляемый средний индекс массива (low + high) // 2
5. Определяем переменную middle_value принимающую значение элемента массива с индексом middle.
6. Ветвление: 	если middle_value == desired_number, т е среднее значение равно искомому значению, возвращаем middle
				если middle_value > desired_number, то верхнее значение индекса массива принимает значение middle - 1
				иначе нижнее значение индекса списка принимает middle + 1
Функция возвращает None если ничего не найдено.

def binary_search(list, desired_number):  # определяем фуекцию, которая принимает на вход массив и искомое число
    low = 0  # первый индекс массива
    high = len(list) - 1  # последний индекс массива

    while low <= high:
        middle = (low + high) // 2  # делить обязательно // чтобы не получить float
        middle_value = list[middle]  # переменная принимает значение текущей середины массива
        if middle_value == desired_number:  # если число найдено, возвращаем индекс
            return middle
        elif middle_value > desired_number: # если искомое число меньше значения середины массива, верхний край 
            # массива переносим в середину 
            high = middle - 1
        else:   # если искомое число больше значения середины массива, нижний край массива переносим в середину
            low = middle + 1
    return None


my_list = [1, 2, 3, 5, 6, 7, 9, 10]
print(binary_search(my_list, 7))
print(binary_search(my_list, 15))

Chapter 2
Sort of choise

Для начала разберем функцию поиска наименьшего элемента массива. Алгоритм:
1. Определим функцию которая принимает в качестве аргумента массив.
2. Определим две переменные, одна будет принимать наименьшее значение массива( например smallest), другая индекс этого значения(smallest_index).
3. В цикле for с помощью range() итерируем массив начиная со второго элемента(первый элемент уже лежит в smallest). Если текущий элемент массива arr[i] < smallest, то это значение передаем в smallest, a его индекс в smallest_index.
4. Цикл for возвращает индекс наименьшего числа.

def find_smallest(arr):
    smallest = arr[0]  # первое значение массива
    smallest_index = 0  # инициируем переменную для индекса
    for i in range(1, len(arr)):  # итерация массива
        if arr[i] < smallest:  # ищем наименьшее текущее значение
            smallest = arr[i]  # если находим, записываем в переменную
            smallest_index = i  # записываем индекс наименьшего значения
    return smallest_index  # в результате функция вернет индекс наименьшего значения

Теперь напишем алгоритм для функции сортировки:
1. Определим фуекцию.
2. Создадим пустой массив sort_arr, куда будем принимать сортировку.
3. В цикле for итерируем массив len(arr) раз.
	Каждую итерацию вызываем фукцию find_smallest() и присваиваем возвращаемое значение smallest.
	Также каждую итерацию для массива sort_arr применяем метод append, который добавит текущее значение в конец массива. append 		принимает аргументом сортируемый массив arr c примененным к нему методом pop, который вырежет из массива текущее значение 		smallest, и вернет его для append.
4. Цикл for возвращает отсортированный массив sort_arr

На основе двух функций производим сортировку массива по возрастанию:

def find_smallest(arr):
    smallest = arr[0]  # первое значение массива
    smallest_index = 0  # инициируем переменную для индекса
    for i in range(1, len(arr)):  # итерация массива
        if arr[i] < smallest:  # ищем наименьшее текущее значение
            smallest = arr[i]  # если находим, записываем в переменную
            smallest_index = i  # записываем индекс наименьшего значения
    return smallest_index  # в результате функция вернет индекс наименьшего значения


def sort_by_choise(arr):
    sort_arr = []  # массив который будет принимать сортированные значения
    for i in range(len(arr)):
        smallest = find_smallest(arr)  # при каждой итерации возвращается наименьшее значение массива arr
        sort_arr.append(arr.pop(smallest))  # при каждой итерации в конец нового массива добавляется  
        # вырезанное из сортируемого массива значение 
    return sort_arr  # возвращаем новый сортированный массив


my_arr = [2, 1, 9, 7, 14, 3, 18, 11]
print(sort_by_choise(my_arr))

Chapter 3

Рекурсия. При использовании рекурсии необходимо установить базовый случай. Это условие при достижении которого вызов рекурсии прекращается. Алгоритм использования рекурсии при вычислении факториала:
1. Определить функцию.
2. Используя ветвление определить базовый случай и вызвать рекурсию:
	если достигнуто условие базового случая, выходим из функции
	в противном случае вызываем рекурсию.
3. Возвращаем вычисленное значение.

def calculation_of_factorial_by_recursion(num):
	if num == 0:
		return 1
	return num * calculation_of_factorial_by_recursion(num - 1)

def calculation_of_factorial_by_cycle(num):
	factorial = 1
	for i in range(2, num + 1):
		factorial *= i 
	return factorial

Chapter 6
Breadth-first search.

Графы реализованы в Python в качестве словарей. Графы имеют узлы и ребра и призваны найти кратчайшее и самое дешевое расстояние от узла A до узла B. Задача: найти среди друзей в телефонной книге продавца манго.
Алгоритм поиска состоит из 6 пунктов:
1. Create a new dictionary where a key equal name of human, value equal friends of human.
2. Extract a next person.
3. Check an unverified person.
4. There is a branch here: if human is a mango's seller - ends a cycle, else adds all friends of human.
5. Cycle works.
6. If the queue is empty the end.

from collections import deque  # функция  deque() создает очередь из итерируемого объекта

graph = {}
graph["you"] = ["alice", "bob", "claire"]
graph["bob"] = ["anuj", "peggy"]
graph["alice"] = ["peggy"]
graph["claire"] = ["thom", 'jonny']
graph["anuj"] = ["mango"]
graph["peggy"] = []
graph["thom"] = []
graph["jonny"] = []


def search(name):
    search_queue = deque()  # создает новую очередь
    search_queue += graph[name]  # alice, bob, claire добавляются в очередь поиска
    searched = []  # массив для отслеживания проверенных людей
    while search_queue:  # so search_queue == True
        person = search_queue.popleft()  # popleft() - удаляет и возвращает первый элемент очереди
        if person not in searched:  # проверка продолжится при условии что человек ранее не проверялся
            if person_is_seller(person):  # функция проверяет евляется ли человек продавцом манго
                print(person + " is a mango seller!")
                return True
            else:
                search_queue += graph[person]  # если не является, все его друзья добавляются в очередь поиска
                searched.append(person) # проверенных людей добавляем в массив
    return False  # выходим из цикла если перебрали всех друзей и продавец не найден

def person_is_seller(name):
    return name[:] == 'mango'  # если есть имя  'mango' , то он продавец манго

search("you")
	
