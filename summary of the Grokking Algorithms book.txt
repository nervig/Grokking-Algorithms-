Конспект по книге Грогаем алгоритмы.
Chapter 1.
Один из самых быстрых алгоритмов поиска в сортированном списке, в целом выглядит так:
1. Определяем функцию которая принимает два аргумента - массив и искомое число.
2. Определяем две переменные, первая ссылается на индекс первого элемента массива, вторая индекс последнего элемента массива.
3. Запускаем цикл который работает пока индекс последнего элемента цикла больше либо равен индексу первого элемента.
4. Определяем переменную middle которая хранит ссылку на вычисляемый средний индекс массива (low + high) // 2
5. Определяем переменную middle_value принимающую значение элемента массива с индексом middle.
6. Ветвление: 	если middle_value == desired_number, т е среднее значение равно искомому значению, возвращаем middle
				если middle_value > desired_number, то верхнее значение индекса массива принимает значение middle - 1
				иначе нижнее значение индекса списка принимает middle + 1
Функция возвращает None если ничего не найдено.

def binary_search(list, desired_number):  # определяем фуекцию, которая принимает на вход массив и искомое число
    low = 0  # первый индекс массива
    high = len(list) - 1  # последний индекс массива

    while low <= high:
        middle = (low + high) // 2  # делить обязательно // чтобы не получить float
        middle_value = list[middle]  # переменная принимает значение текущей середины массива
        if middle_value == desired_number:  # если число найдено, возвращаем индекс
            return middle
        elif middle_value > desired_number: # если искомое число меньше значения середины массива, верхний край 
            # массива переносим в середину 
            high = middle - 1
        else:   # если искомое число больше значения середины массива, нижний край массива переносим в середину
            low = middle + 1
    return None


my_list = [1, 2, 3, 5, 6, 7, 9, 10]
print(binary_search(my_list, 7))
print(binary_search(my_list, 15))

Chapter 6.
Breadth-first search.

Графы реализованы в Python в качестве словарей. Графы имеют узлы и ребра и призваны найти кратчайшее и самое дешевое расстояние от узла A до узла B. Задача: найти среди друзей в телефонной книге продавца манго.
Алгоритм поиска состоит из 6 пунктов:
1. Create a new dictionary where a key equal name of human, value equal friends of human.
2. Extract a next person.
3. Check an unverified person.
4. There is a branch here: if human is a mango's seller - ends a cycle, else adds all friends of human.
5. Cycle works.
6. If the queue is empty the end.

from collections import deque  # функция  deque() создает очередь из итерируемого объекта

graph = {}
graph["you"] = ["alice", "bob", "claire"]
graph["bob"] = ["anuj", "peggy"]
graph["alice"] = ["peggy"]
graph["claire"] = ["thom", 'jonny']
graph["anuj"] = ["mango"]
graph["peggy"] = []
graph["thom"] = []
graph["jonny"] = []


def search(name):
    search_queue = deque()  # создает новую очередь
    search_queue += graph[name]  # alice, bob, claire добавляются в очередь поиска
    searched = []  # массив для отслеживания проверенных людей
    while search_queue:  # so search_queue == True
        person = search_queue.popleft()  # popleft() - удаляет и возвращает первый элемент очереди
        if person not in searched:  # проверка продолжится при условии что человек ранее не проверялся
            if person_is_seller(person):  # функция проверяет евляется ли человек продавцом манго
                print(person + " is a mango seller!")
                return True
            else:
                search_queue += graph[person]  # если не является, все его друзья добавляются в очередь поиска
                searched.append(person) # проверенных людей добавляем в массив
    return False  # выходим из цикла если перебрали всех друзей и продавец не найден

def person_is_seller(name):
    return name[:] == 'mango'  # если есть имя  'mango' , то он продавец манго

search("you")
	
